#!/usr/bin/env bash
#    _____ _     ____  ____  ____  ____  _____
#   /    // \   /  _ \/  __\/  _ \/  __\/__ __\
#   |  __\| |   | / \||  \/|| / \||  \/|  / \
#   | |   | |_/\| |-|||  __/| \_/||    /  | |
#   \_/   \____/\_/ \|\_/   \____/\_/\_\  \_/

# ---------------------------------------------------- #
# !!! NOTE THAT THIS SCRIPT SHOULD NOT BE SOURCED. !!! #
# ---------------------------------------------------- #

# last complete install: 2020.05.11

# Note: this script does NOT attempt to be an exact copy for `arch_install`.
#       It just attempts to give a similar feel in the terminal of my
#       debian/ubuntu servers.

# Note: this script can be run as often as you like. It will not attempt to re-install
#       any already installed program, making it a very fast way update some preferences
#       or install additional packages by adding them to the list below.


## Checks
#-------------------------------------------------------------------------------

## pre-installation checks
if [ "$USER" == root ]; then
    echo
    echo "'arch_install' should NOT be run as root, nor should it be run with sudo."
    echo "this script should be run [normally] by a user with sudo privileges."
    exit 1
fi

if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    echo
    echo "'arch_install' should NOT be sourced."
    exit 1
fi


## Parse arguments
#-------------------------------------------------------------------------------

[ ! -z "$2" ] && >&2 echo usage: arch_install [--force] && exit 1
[ ! -z "$1" ] && [  "$1" = "--force" ] && FORCE=1 || FORCE=0


## Logging
#-------------------------------------------------------------------------------

mkdir -p $HOME/.local/share
LOG="$HOME/.local/share/debian_install.log"
ERR="$HOME/.local/share/debian_install_errors.log"
printf "DEBIAN PACKAGE INSTALL\n\n\n" > $LOG
printf "DEBIAN PACKAGE INSTALL\n\n\n" > $ERR


## User input
#-------------------------------------------------------------------------------

# Ask for password, this will be used for all the sudo calls.:
# and to change the shell later on.
read -s -p "[sudo] password for $USER: " password
echo $password | sudo -S echo '' 2>/dev/null
if [ $? -ne 0 ]; then
    printf "\nIncorrect sudo password. Script ended prematurely.\n\nPlease start over.\n\n"
    exit 1
fi


## Update
#-------------------------------------------------------------------------------

## Update arch
printf "\n\nUpdating...\n\n"
printf "\n\nUpdating...\n\n" >> $LOG
printf "\n\nUpdating...\n\n" >> $ERR
echo $password | sudo -S apt update -y >> $LOG 2>> $ERR
echo $password | sudo -S apt upgrade -y >> $LOG 2>> $ERR


## Custom installation functions
#-------------------------------------------------------------------------------

echo_success(){
    if [ $1 -ne 0 ]; then
        printf "failed!\n"
        printf "\nfailed!\n" >> $LOG
        printf "\nfailed!\n" >> $ERR
        return 1
    fi

    printf "success!\n"
    printf "\nsuccess!\n" >> $LOG
    printf "\nsuccess!\n" >> $ERR
    return 0
}

apt_install(){ # will only install the first argument!
    printf "installing $1... "
    printf "\n\n\ninstalling $1...\n" >> $LOG
    printf "\n\n\ninstalling $1...\n" >> $ERR

    # check if package is already installed...
    dpkg -l $1 >> $LOG 2>> $ERR;
    if [ $? = 0 ] && [ "$FORCE" -eq 0 ]; then
        printf "already installed.\n"
        printf "already installed.\n" >> $LOG
        printf "already installed.\n" >> $ERR
        return 1
    fi

    printf "sudo apt install -y $1\n" >> $LOG
    printf "sudo apt install -y $2\n" >> $ERR
    echo $password | sudo -S apt install -y $1 >> $LOG 2>> $ERR
    exit_code=$?
    echo_success $exit_code
    return $exit_code
}

pip3_install() {
    printf "pip3 install $1... "
    printf "\n\n\npip3 install $1\n" >> $LOG
    printf "\n\n\npip3 install $1\n" >> $ERR
    printf "sudo /usr/bin/python3 -m pip install $1\n" >> $LOG
    printf "sudo /usr/bin/python3 -m pip install $1\n" >> $ERR
    echo $password | sudo -S /usr/bin/python3 -m pip install $1 >> $LOG 2>> $ERR
    exit_code=$?
    echo_success $exit_code
    return $exit_code
}

systemctl_create() {
    printf "creating $1 service... "
    printf "\n\n\ncreating $1 service...\n" >> $LOG
    printf "\n\n\ncreating $1 service...\n" >> $ERR
    source=$HOME/.install/services/$1.service
    target=$(head -6 $source | tail -1 | sed 's/#\ *TARGET:\ *//g')

    echo $password | sudo -S systemctl daemon-reload
    echo "# NOTE: THIS FILE WAS AUTO-GENERATED BY $HOME/.install/arch_install" | sudo tee $target > /dev/null 2>> $ERR
    echo "# AND WILL PROBABLY BE OVERWRITTEN IN THE FUTURE." | sudo tee -a $target > /dev/null 2>> $ERR
    echo "# EDIT THE SOURCE FILE AT $source" | sudo tee -a $target > /dev/null 2>> $ERR
    echo "# and run $HOME/.install/arch_install again to install it here." | sudo tee -a $target > /dev/null 2>> $ERR
    echo "" | sudo tee -a $target > /dev/null 2>> $ERR
    tail --lines=+7 $source | sed 's|{USER}|'$USER'|g' | sed 's|{HOME}|'$HOME'|g' | sudo tee -a $target > /dev/null 2>> $ERR
    exit_code=$?
    echo $password | sudo -S systemctl daemon-reload
    echo_success $exit_code
    return $exit_code
}

systemctl_enable() {
    printf "enabling $1 service... "
    printf "\n\n\nenabling $1 service...\n" >> $LOG
    printf "\n\n\nenabling $1 service...\n" >> $ERR
    printf "sudo systemctl enable $1\n" >> $LOG
    printf "sudo systemctl enable $1\n" >> $ERR
    echo $password | sudo -S systemctl enable "$1" >> $LOG 2>> $ERR
    exit_code=$?
    echo_success $exit_code
    return $exit_code
}

link() {
    [ ! -z $3 ] && printf "link: too many arguments" && return 1
    printf "link $1 to $2... "
    printf "\n\n\nlink $1 to $2\n" >> $LOG
    printf "\n\n\nlink $1 to $2\n" >> $ERR
    printf "sudo ln -sf $1 $2\n" >> $LOG
    printf "sudo ln -sf $1 $2\n" >> $ERR
    [ -f "$2" ] && echo $password | sudo -S mv $2 $2.bak  >> $LOG 2>> $ERR
    echo $password | sudo -S ln -sf $1 $2  >> $LOG 2>> $ERR
    exit_code=$?
    echo_success $exit_code
    return $exit_code
}


## Install and configure packages
#-------------------------------------------------------------------------------

## build tools
apt_install git
apt_install make
apt_install cmake
apt_install build-essential

## Terminal
# search tool
apt_install grep
# alternative search tool
apt_install ripgrep
# alternative search tool
# apt_install ack
# fuzzy finder tool
apt_install fzf
# rsync: safe and secure copy & backup
apt_install rsync
# atool gives information about archives
# apt_install atool
# zip
apt_install zip
# unzip
apt_install unzip
# pv: progress bars on stdout
apt_install pv
# vifm: terminal file browser
apt_install vifm
# dos2unix: tool to change carriage return (^M | \r) into nomal return (\n)
# apt_install dos2unix
# terminal multiplexer:
apt_install tmux
# run tmux as a systemd service:
systemctl_create tmux
systemctl_enable tmux
# program manuals
apt_install man
apt_install man-db
apt_install texinfo
# very useful alternative to man: show most common commands for executable
apt_install tldr
# terminal music player: mplayer
# apt_install mplayer
# copying and pasting from the terminal
# apt_install xclip
# check if bash script is posix complient (needs haskell -> 250mb -> disabled by default)
# apt_install shellcheck
# highlight: to highlight code in the terminal (nice `cat` alternative, used in my custom scripts)
apt_install highlight
# mediainfo: show audio and video information in terminal
# apt_install mediainfo
# process information
apt_install htop
# system information
apt_install neofetch
# large ascii letters
apt_install figlet
# task spooler: queue tasks
# apt_install task-spooler
# sockets (needed for custom mpvcontrol script)
apt_install socat
# torrents: transmission
apt_install transmission-cli
apt_install transmission-remote-cli
# a more beautiful ls command (I have ls remapped to lsd when no arguments given)
# apt_install lsd [not yet in repositories]
# vim / neovim: terminal text editor
apt_install neovim
# link neovim to standard vim binary:
# link /usr/bin/nvim /usr/bin/vim
# ctags: recommended vim dependency for jump-to-tag functionality
apt_install ctags
# trans: command line translation engine
# apt_install translate-shell
# whois information
apt_install whois
# file conversions
apt_install pandoc
# matlab alternative:
apt_install octave
# html email view (also browser!)
# apt_install w3m
# html email view alternative (also browser!)
apt_install lynx
# python-neovim integration
apt_install python-neovim

## Drive and file system drivers
# mount cifs parititions
apt_install cifs-utils
# dosfstools: support for dos (windows) - like filesystems
apt_install dosfstools
# exfat-utils: access fat-drives
apt_install exfat-utils
# ntfs-3g: access NTFS network drives
apt_install ntfs-3g
# samba shares = network volumes
# apt_install samba
# access media on external device (phone, ...)
apt_install fuse
# access ssh file system
apt_install sshfs
# nodejs:
# apt_install nodejs
# node package manager
# apt_install npm


## Web interfaces
# syncthing: synchronization between devices
apt_install syncthing
# run syncthing as a systemd service
systemctl_create syncthing
# systemctl_enable syncthing

## Printers
# printer system (cups @ localhost:631)
# apt_install cups
# print to pdf
# apt_install cups-pdf
# enable cups service
# systemctl_enable org.cups.cupsd


## Shells and extensions
#-------------------------------------------------------------------------------

# dash: a minimal implementation of sh:
apt_install dash
# we'll make sh point to dash in stead to bash
# link /usr/bin/dash /bin/sh
# make dash the default shell:
# echo $password | chsh -s /bin/dash 2>> $LOG >> $ERR

# bash: should already have been installed:
# apt_install bash
# make bash the default shell:
# echo $password | chsh -s /bin/bash 2>> $LOG >> $ERR

# fish: alternative shell. It's not posix complient, but friendly and interactive ;)
# apt_install fish
# make fish the default shell:
# echo $password | chsh -s /usr/bin/fish 2>> $LOG >> $ERR

# zsh: another alternative shell. In contrast to fish, it is posix complient + extras
# it's my preferred shell.
apt_install zsh
# make zsh the default shell:
echo $password | chsh -s /usr/bin/zsh >> $LOG 2>> $ERR

# autojump extension for bash/zsh/fish, I could not live without it:
mkdir -p $HOME/.cache
rm -rf $HOME/.cache/autojump
git clone https://github.com/wting/autojump $HOME/.cache/autojump 2>> $LOG >> $ERR
cd $HOME/.cache/autojump 2>> $LOG >> $ERR
python install.py -d $HOME/.config/autojump 2>> $LOG >> $ERR
sed -i 's|#!/usr/bin/env python|#!/usr/bin/python|' $HOME/.config/autojump/bin/autojump >> $LOG 2>> $ERR

# stderred extension for bash/zsh: show stderr messages in red:
rm -rf $HOME/.config/stderred
git clone https://github.com/sickill/stderred $HOME/.config/stderred 2>> $LOG >> $ERR
cd $HOME/.config/stderred 2>> $LOG >> $ERR
make 2>> $LOG >> $ERR

# fish-like autosuggestions for zsh:
rm -rf $HOME/.config/zsh/zsh-autosuggestions
git clone https://github.com/zsh-users/zsh-autosuggestions $HOME/.config/zsh/zsh-autosuggestions 2>> $LOG >> $ERR

# syntax highlighting for zsh:
rm -rf $HOME/.config/zsh/zsh-syntax-highlighting
git clone https://github.com/zsh-users/zsh-syntax-highlighting $HOME/.config/zsh/zsh-syntax-highlighting 2>> $LOG >> $ERR

# zsh package manager (i do not really recommend this):
# yay_install oh-my-zsh-git

## Finished
#-------------------------------------------------------------------------------

printf "\n\n\n\n\n"
echo "###############"
echo "## finished! ##"
echo "###############"

